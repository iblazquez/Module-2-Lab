import {spawn} from 'child_process'

export class Server {

	constructor(spawn = ['npm', ['start']],
		{delay = 30, timeout = 5, signal = 'SIGTERM'}
	) {
		this.spawn = spawn
		this._delay = delay
		this._timeout = timeout
		this._signal = signal
	}

	get spawnArgs() {
		return this._spawnArgs
	}
	set spawnArgs([command, args, options = {}]) {
		const {detached, env} = options
		if (detached !== undefined && !detached)
			throw new Error('server process must be detached')
		this._spawnArgs = [
			command, args,
			{
				detached: true,
				env: {NODE_ENV: 'development', DEBUG: '*', ...env},
				...options
			}
		]
	}

	get status() {
		return this._status
	}
	set status(value) {
		this._status = value
		console.log(this._status)
	}

	start() {
		return new Promise((resolve, reject) => {
			this.process = spawn(...this.spawnArgs)
			this.process.once('error', reject)
			setTimeout(resolve, this._delay)
			this.status = 'starting'
		}).then(_ => this.status = 'started')
	}
	async stop() {
		this.status = 'stopping'
		this.process.on('exit', code => {
			this.status = 'stopped'
			setImmediate(() => {
				if (!existsProcess(-gid)) resolve()
				else {
					const gid = this.process.pid
					process.kill(-gid, 'SIGHUP')
					process.kill(-gid, 'SIGCONT')
					resolve(processExited(-gid))
				}
			}))
		}
		this.process.kill()
		try {
			await processExited(-gid, {timeout: this._timeout})
		} catch (e) {
			process.kill(-gid, 'SIGKILL')
		}
		return this.stopped
	}
	async restart() {
		try {
			await this.stop()
		} catch (e) {
			console.log('Error:', e)
			await this.forceStop()
		}
		await this.start()
	}
}

export function existsProcess(pid) {
	try {
		process.kill(pid, 0)
		return true
	} catch (e) {
		return false
	}
}

export async function processExited(pid,
	{timeout = 5000, checkInterval = timeout / 16}
) {
	const startTime = Date.now()
	while (existsProcess(pid)) {
		await sleep(checkInterval)
		if (Date.now() - startTime > timeout) throw new Error('timeout')
	}
}
